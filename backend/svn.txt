# app.py
import shutil
import tempfile
from pathlib import Path
from typing import Optional, List, Dict, Any

from fastapi import FastAPI, UploadFile, File, HTTPException
from pydantic import BaseModel
import pandas as pd
import os
import json
import csv

app = FastAPI(title="Excel/CSV Inspector")

UPLOAD_DIR = Path(tempfile.gettempdir()) / "excel_uploads"
UPLOAD_DIR.mkdir(parents=True, exist_ok=True)

def save_upload_file(upload_file: UploadFile, dest: Path) -> None:
    with dest.open("wb") as buffer:
        shutil.copyfileobj(upload_file.file, buffer)

def extract_from_excel_file(path: Path, max_preview_rows: int = 50) -> Dict[str, Any]:
    try:
        df = pd.read_excel(path)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Failed to read excel file: {e}")

    headers = list(df.columns)
    nrows = int(len(df))
    preview_df = df.head(max_preview_rows).fillna("")
    preview = preview_df.to_dict(orient="records")
    sample_values = []
    if headers:
        first_col = headers[0]
        sample_values = [str(x).strip() for x in df[first_col].dropna().astype(str).unique().tolist()]

    return {"filename": path.name, "headers": headers, "nrows": nrows, "preview": preview, "sample_values": sample_values}

def extract_from_csv_file(path: Path, max_preview_rows: int = 50) -> Dict[str, Any]:
    """
    Try to read CSV with delimiter sniffing. If auto-detect fails, try common delimiters.
    Remove blank rows at the beginning or anywhere in the file.
    """
    df = None
    # Attempt delimiter sniffing
    try:
        df = pd.read_csv(path, engine="python", sep=None)
    except Exception:
        for sep in [",", ";", "\t", "|"]:
            try:
                df = pd.read_csv(path, sep=sep)
                break
            except Exception:
                df = None

    if df is None:
        raise HTTPException(status_code=400,
                            detail="Failed to parse CSV file (invalid format or delimiter).")

    # ---- REMOVE EMPTY ROWS ----
    # drop rows that are fully NaN
    df = df.dropna(how="all")

    # drop rows that contain only empty strings
    df = df[~(df.astype(str).apply(lambda x: "".join(x).strip(), axis=1) == "")]

    headers = list(df.columns)
    nrows = int(len(df))
    preview_df = df.head(max_preview_rows).fillna("")
    preview = preview_df.to_dict(orient="records")

    sample_values = []
    if headers:
        first_col = headers[0]
        sample_values = [str(x).strip() for x in df[first_col].dropna().astype(str).unique().tolist()]

    return {
        "filename": path.name,
        "headers": headers,
        "nrows": nrows,
        "preview": preview,
        "sample_values": sample_values
    }

@app.post("/api/upload-excel")
async def upload_excel(file: UploadFile = File(...)):
    """
    Uploads an .xls, .xlsx or .csv file. Returns the same JSON shape as before.
    """
    fname = file.filename or ""
    fname_lower = fname.lower()
    if not fname_lower.endswith((".xls", ".xlsx", ".csv")):
        raise HTTPException(status_code=400, detail="Please upload an .xls, .xlsx or .csv file")

    dest = UPLOAD_DIR / fname
    counter = 0
    base = dest.stem
    ext = dest.suffix
    while dest.exists():
        counter += 1
        dest = UPLOAD_DIR / f"{base}_{counter}{ext}"

    try:
        save_upload_file(file, dest)
        if dest.suffix.lower() == ".csv":
            data = extract_from_csv_file(dest)
        else:
            data = extract_from_excel_file(dest)
    finally:
        try:
            dest.unlink()
        except Exception:
            pass

    return {"status": "ok", "data": data}

# The rest of your app (compare endpoint, /health) stays unchanged.
